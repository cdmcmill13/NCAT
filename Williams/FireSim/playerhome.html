<!DOCTYPE html>
<html>
<!-- Player home page -->
<head>
<title>FireSim Player</title>
</head>
<body onload="setInterval(periodic, 2500)">		<!-- call the periodic function periodically -->
<div>
<!-- Firewall configuration input -->
<h3>Enter FireSim configuration</h3>
<textarea id="inText" rows = "8" cols="80"></textarea>
<br>
<button type="button" onclick="checkConfig()">Check Configuration</button><br>

<!-- List of players -->
<table id="playerlist">
<thead>
<tr><th>select</th><th>Name</th><th>Score</th>
</tr>
</thead>
<tbody>
<tr><td><input type="radio" name="playerGroup" onclick="playerSelected(0)"></input>
</td><td>nobody</td><td>100</td></tr>
</tbody>
</table>
<br>

<!-- List of attacks a player can take against another player -->
<p id="weapons">
<button onclick="doAttack('web')" id="web" value="web">Take Action</button>View the home page of their website<br>
<button onclick="doAttack('dns')" id="dns" value="dns">Take Action</button>Retrieve an IP address from their Domain Name Server<br>
<button onclick="doAttack('email')" id="email" value="email">Take Action</button>Send regular email.<br>
<button onclick="doAttack('ftp')" id="ftp" value="NOftp">Take Action</button>Copy a file from their FTP server<br>
<button onclick="doAttack('pop')" id="pop" value="NOpop">Take Action</button>Access email via POP from the Internet.<br>
<button onclick="doAttack('imap')" id="imap" value="NOimap">Take Action</button>Access email via IMAP4 from the Internet.<br>
<button onclick="doAttack('waste')" id="waste" value="NOwaste">Take Action</button>Employees access www.wasteoftime.com.<br>
<button onclick="doAttack('vpn')" id="vpn" value="NOvpn">Take Action</button>VPN access to the network<br>
<button onclick="doAttack('mydoom')" id="mydoom" value="mydoom" disabled>Take Action</button>Mydoom backdoor access to system<br>
</p>

<ul id="msgDisplay">  <!-- Messages need to be a scrollable pane -->
<li style="color:blue;">Dummy playerhome</li>
</ul>

<p id="rawmsg">raw</p>

<script>
// global variables
var simulationRunning = false;						// true when attacks are allowed
var playArray = {players: [{ name:"nobody", score:"0" }]};	// array of the players and scores
var selectedPlayer = null;							// currently selected player
var DELAY2ATTACK = 45000;							// milliseconds until player can attack again
var attackTime =  [ {"attack":"web", "player":"*ALL*", "time":"0"},	// times when attacks are not allowed
					{"attack":"dns", "player":"*ALL*", "time":"0"},
					{"attack":"email", "player":"*ALL*", "time":"0"},
					{"attack":"ftp", "player":"*ALL*", "time":"0"},
					{"attack":"pop", "player":"*ALL*", "time":"0"},
					{"attack":"imap", "player":"*ALL*", "time":"0"},
					{"attack":"waste", "player":"*ALL*", "time":"0"},
					{"attack":"vpn", "player":"*ALL*", "time":"0"},
					{"attack":"mydoom", "player":"*ALL*", "time":"0"}];

/* Show messages in the scrolling message box.
Message types are:
 *   0 = no message (ignore)
 *   1 = message to be displayed on the player's screen
 *   2 = player has been successfully attacked
 *   3 = player has defended against an attack
 *   4 = player's attack was successful
 *   5 = player's attach was unsuccessful
 *   6 = configuration was correctly updated
 *   7 = configuration error
 *   8 = new firewall requirement
 *   9 = start of the simulation
 *   10 = end of the simulation
*/
var typeStyle =["Pink", "Black", "Red", "Blue", "Purple", "Brown", "Green", "OrangeRed", "DarkRed", "Orange", "Lime"];
function showMessage(msgData) {
	document.getElementById("rawmsg").innerHTML = msgData;		//!! DEBUG
	var msgList = JSON.parse( msgData );			// convert data to JavaScript array of objects
	var k;											// for loop index
	var msgCode;									// message type of single message
	var what2say;									// text of the message
	for (k = 0; k < msgList.msg.length; k++) {
		what2say = msgList.msg[k].text;
		msgCode  = msgList.msg[k].type;
		if (msgCode != 0) {							// ignore message code zero
			if (msgCode == 8) {						// if new config requirement
				document.getElementById(msgList.msg[k].chgID).value = msgList.msg[k].newval;	// update attack
				document.getElementById(msgList.msg[k].chgID).innerHTML = document.getElementById(msgList.msg[k].chgID).innerHTML + msg[k].newval;	//!!DEBUG append new attack
				document.getElementById(msgList.msg[k].chgID).disabled = false;		// enable attack
				restrictAll(msgList.msg[k].chgID);	// set deadline before anyone can use this attack
			} else if (msgCode == 9) {				// if start of the simulation
				simulationRunning = true;			// allow all attacks
			} else if (msgCode == 10) {				// if this is the end of the simulation
				simulationRunning = false;			// disable all attacks
			}
			// message should be added to the end of the scrolling display with the proper style 
			// based on the type of the message
			var node = document.createElement("LI");
			var textnode = document.createTextNode(what2say);
			node.appendChild(textnode);
			node.style.color = typeStyle[msgCode];
			document.getElementById("msgDisplay").appendChild(node);
		}
	}
}

// Send the firewall configuration to the server
function checkConfig() {
  var netObj = new XMLHttpRequest();
  netObj.onreadystatechange = function() {
    if (netObj.readyState === 4 && netObj.status === 200) {
      showMessage(netObj.responseText);			// display results 
    }
  };
  var configText = document.getElementById("inText").value;
  netObj.open("POST", "checkConfig.php", true);
  netObj.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
  netObj.send("conftext=" + configText);
}

// Take an action against another player
// attackID is the ID of the button for this attack
function doAttack(attackID) {
	if (!simulationRunning) {									// if attacks not allowed yet
		showMessage('{"msg": [{"text":"Actions are not allowed until the instructor permits them","type":"5"}]}');
	} else if (selectedPlayer == null) {
		showMessage('{"msg": [{"text":"You must select a player to act upon","type":"5"}]}');
	} else {
		var attackType = document.getElementById(attackID).value;
		var blocked = attackBlock(attackID, selectedPlayer);	// check if this attack is allowed
		if (blocked) {											// if attack is not allowed
			showMessage(blocked);								// display wait time message
			return;												// attack will not occur at this time
		}
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (xhttp.readyState == 4 && xhttp.status == 200) {
				showMessage(xhttp.responseText);			// display results 
			}
		};
		xhttp.open("POST", "http://localhost/FireSim/go4Blood.php", true);
		xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		xhttp.send("victim=" + selectedPlayer + "&weapon=" + attackType);
	}
}


// Send a request to the server for any messages sent to this user
function ask4msg() {
	var xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function() {
		if (xhttp.readyState == 4 && xhttp.status == 200) {
			showMessage(xhttp.responseText);			// display results 
		}
	};
	xhttp.open("GET", "http://localhost/FireSim/retrieveMsg.php", true);
	xhttp.send();
}

// playerSelected is called when a radio button in the player list is clicked
function playerSelected(who) {
	selectedPlayer = playArray.players[who].name;
}

// gteList requests a new list of players from the server
function getList() {
	var xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function() {
		if (xhttp.readyState == 4 && xhttp.status == 200) {
			playArray = JSON.parse(xhttp.responseText);
			playerUpdate();
		}
	};
  xhttp.open("GET", "http://localhost/FireSim/refreshplayers.php", true);
  xhttp.send();
}

// playerUpdate refreshes the list of players from playArray created by getList()
// If a player was previously selected, their radio button remains selected.
function playerUpdate() {
	var tbl = "<thead><tr><th>Select</th><th>Name</th><th>Score</th></tr></thead><tbody>";
	var i;
	for (i = 0; i < playArray.players.length; i++) {
		tbl += '<tr><td><input type="radio" name="playerGroup" onclick="playerSelected('+ i +')"';
		if (selectedPlayer != null && selectedPlayer == playArray.players[i].name) {
			tbl += ' checked="true"';			// if this player previously selected
		}
		tbl += '></input></td><td>' + playArray.players[i].name + '</td><td>'  +
			playArray.players[i].score + '</td></tr>';
	}
	tbl += '</tbody></table>';
	document.getElementById("playerlist").innerHTML = tbl;
}

/* This method returns FALSE if the "how" attack on player "who" is ALLOWED at this time.
 * If this attack is not allowed at this time, it returns a string containing an error message
 * in appropriate JSON array format.
 */
function attackBlock(how, who) {
	var now = (new Date()).getTime();					// get current time in milliseconds since epoch
	var nextTime;										// time until next attack
	var ax;
	for (ax = 0; ax < attackTime.length; ax++) {
		if (attackTime[ax].attack == how) {				// if this is the specified type of attack
			if (attackTime[ax].player == "*ALL*") {		// check for any restriction on all players
				if (attackTime[ax].time > now) {		// too soon to attack?
					nextTime = ((attackTime[ax].time - now)/1000 + 1).toFixed(0);
					return '{"msg": [{"text":"You must wait ' + nextTime + ' more seconds to take a ' +
								how + ' action","type":"5"}]}';
				}
			} else if (attackTime[ax].player == who) {	// if attack directed at this specific player
				if (attackTime[ax].time > now) {		// too soon to attack again?
					nextTime = ((attackTime[ax].time - now)/1000 + 1).toFixed(0);
					return '{"msg": [{"text":"You must wait ' + nextTime + ' more seconds before you can take a ' +
									how + ' action against ' + who + '","type":"5"}]}';
				} else {								// attack against this player is allowed
					nextTime = now + DELAY2ATTACK;		// time when attack allowed again
					attackTime[ax].time = nextTime;		// reset limit until next attack of this type
					return false;						// attack is allowed
				}			
			}
		}
	}
	// first attack of this type against this player.  Create entry in the array
	nextTime = now + DELAY2ATTACK;					// time when attack allowed again
	attackTime.push({attack: how, player: who, time: nextTime}); // set deadline
	return false;			// attack is allowed
}

/* Restrict attack on any player until after the expiration time.
 * This is intended to be used when a new configuration change is made.
 */
function restrictAll(whatAttack) {
	var aix;
	for (aix = 0; aix < attackTime.length; aix++) {
		if (attackTime[aix].attack == whatAttack && attackTime[aix].player == "*ALL*") {	// if this type of attack
			attackTime[aix].time = (new Date()).getTime() + DELAY2ATTACK;	// set deadline
			return;
		}
	}
}

/* This method is automatically called periodically to update the scores and messages.
 */
function periodic() {
	ask4msg();			// update the messages
	getList();			// update the list of players
}
</script>
</div>

</body>

</html>
